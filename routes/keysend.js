const express = require("express");
const LndGrpc = require("lnd-grpc");
const crypto = require("crypto");

const router = express.Router();

// Store LndGrpc instances for each user
const grpcInstances = {};

module.exports = (wss) => {
  // Setup-listen route: for setting up gRPC connection and start listening for keysends.
  router.post("/setup-listen", async (req, res) => {
    try {
      const { host, cert, macaroon } = req.body;

      // Create a new instance of the LndGrpc class for the user's node
      const grpcReceiver = new LndGrpc({ host, cert, macaroon });

      // Store the instance using the user's host as a key
      grpcInstances[host] = grpcReceiver;

      // Connect to the gRPC server
      await grpcReceiver.connect();

      // Check the connection state
      if (grpcReceiver.state !== "active") {
        return res.status(500).json({
          message: "Connection not stable. Please try again later",
        });
      }

      const { Lightning } = grpcReceiver.services;

      // Get info about the node
      const info = await Lightning.getInfo({});

      // Send a success response with the user's alias
      res.json({
        message: "Successfully started listening for keysends.",
        alias: info.alias,
        pubKey: info.identity_pubkey,
      });
    } catch (error) {
      console.error("Could not connect to the receiving LND node:", error);
      res.status(500).json({ message: "Error connecting to LND node", error });
    }
  });

  // Send-payment route: for sending payment from one node to another
  router.post("/send-payment", async (req, res) => {
    try {
      const { host, destination, message } = req.body;

      const grpc = grpcInstances[host];
      if (!grpc) {
        return res.status(400).json({
          message: "User not initialized. Please call /setup-listen first.",
        });
      }

      const { Lightning } = grpc.services;

      // Get sender's node info to extract public key
      const senderInfo = await Lightning.getInfo({});

      // Define payment amount (in sats)
      const amount = 1100;

      // Create preimage and payment_hash
      const preimage = crypto.randomBytes(32);
      const payment_hash = crypto
        .createHash("sha256")
        .update(preimage)
        .digest();

      // Construct payment request
      const paymentRequest = {
        // Destination public key (hex-encoded string converted to a Buffer)
        dest: Buffer.from(destination, "hex"),
        // Amount of satoshis to send
        amt: amount,
        // Unique payment identifier (buffer), generated by hashing the preimage
        payment_hash: payment_hash,
        // Time-lock value which determines the number of blocks a receiver has to claim a payment
        // (it's a sort of expiry limit). Here, the recipient has 40 blocks to claim.
        final_cltv_delta: 40,
        // Custom records that include arbitrary data sent with the payment.
        // Here it's used to send a message and a preimage.
        dest_custom_records: {
          // A custom field for sending a message, encoded in UTF8
          34349334: Buffer.from(message, "utf8"),
          // A custom field for the preimage of the payment hash
          5482373484: preimage,
        },
        // The transaction will timeout if it's not completed within 60 seconds
        timeout_seconds: 60,
        // Maximum fee that we are willing to pay for this payment.
        // Here, it's a fixed amount of 1000 satoshis.
        fee_limit: { fixed: 1000 },
        // Features required in the destination node
        // 9 refers to the feature: tlVOnionPayloadOptional (variable length onion)
        dest_features: [9],
      };

      // Send payment and await response
      const paymentResponse = await Lightning.sendPaymentSync(paymentRequest);

      // Broadcast sent message
      wss.broadcast(
        JSON.stringify({
          senderHost: host,
          senderPubKey: senderInfo.identity_pubkey,
          receiverPubKey: destination,
          alias: senderInfo.alias,
          message,
          timestamp: new Date().toISOString(), // add timestamp here
        })
      );

      // Return only relevant information
      res.json({
        payment_preimage: paymentResponse.payment_preimage.toString("hex"),
        payment_route: paymentResponse.payment_route,
      });
    } catch (error) {
      // Catch and log any errors, return 500 status code
      res
        .status(500)
        .json({ error: "An error occurred while sending the payment." });
      console.error("An error occurred:", error);
    }
  });

  return router;
};
